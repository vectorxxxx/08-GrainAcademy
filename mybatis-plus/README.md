## 1、 GMT 和 UTC 的区别是什么？

`GMT` 和 `UTC` 都是时区缩写，但它们之间存在一些差异。

1. 定义不同：
    - `GMT`（`Greenwich Mean Time`）是英国夏令时（`DST`）之前的标准时间，以英国伦敦的当地时间为基准。
    - `UTC`（`Coordinated Universal Time`）是国际标准时间，以 `UTC` 时间为基准。

2. 应用范围不同：
    - `GMT` 主要应用于英国及其它一些国家。
    - `UTC` 则被广泛应用于国际标准时间，是国际上通用的标准时间。

3. 时间格式不同：
    - `GMT` 的时间格式为 "`HH:MM:SS+00:00`"，其中"`+`"表示小时数，`00:00` 表示分钟和秒。
    - `UTC` 的时间格式为 "`HH:MM:SSZ`"，其中 "`Z`" 表示零时区。

4. 夏令时（`DST`）不同：
    - `GMT`在夏令时期间会使用夏令时，但夏令时切换的时间是当地时区的时间，而不是 `UTC` 时间。
    - `UTC` 时区不会使用夏令时。

5. 夏令时切换的时间不同：
    - `GMT` 夏令时切换的时间是当地时区的时间，例如夏令时开始的时间可能是当地时区的中午 12 点。
    - `UTC` 时区夏令时切换的时间是 `UTC` 时间的中午 12 点。

因此，在实际应用中，我们通常使用 `UTC` 时区来表示国际标准时间，因为它更具通用性和一致性。



## 2、ID_WORKER 和 ID_WORKER_STR 区别是什么？

`ID_WORKER` 和 `ID_WORKER_STR` 两个常量，分别表示整数类型和字符串类型。

```java
// ID_WORKER
@TableId(type = IdType.ID_WORKER)
private Long id;
// ID_WORKER_STR
@TableId(type = IdType.ID_WORKER_STR)
private String id;
```



## 3、snowflake     算法是什么？

`Snowflake` 算法是一种分布式系统中生成唯一 ID 的算法，它可以在不依赖数据库的情况下生成全局唯一的 ID。`Snowflake` 算法的核心思想是将当前时间、数据中心 ID、工作节点 ID 和序列号组合起来生成一个 64 位整数，作为分布式系统中每个实体的唯一 ID。

`Snowflake` 算法的优势在于生成的 ID 是全局唯一的，并且在不同数据中心和工作节点之间也是唯一的。这使得在分布式系统中，可以使用 `Snowflake` 算法来保证每个实体具有唯一的 ID，避免 ID 冲突的问题。

`Snowflake` 算法的实现包括四个部分：

1. **时间戳**：使用当前时间戳，精确到毫秒。
2. **数据中心 ID**：使用一个 10 位的二进制整数表示数据中心 ID，其中高 4 位表示数据中心 ID，低 6 位表示机器 ID。
3. **工作节点 ID**：使用一个 12 位的二进制整数表示工作节点 ID，其中高 8 位表示工作节点 ID，低 4 位表示序列号。
4. **序列号**：使用一个 8 位的二进制整数表示序列号，用于保证在高并发情况下生成的 ID 是唯一的。

通过这四个部分，`Snowflake` 算法可以生成一个 64 位整数，作为分布式系统中每个实体的唯一 ID。



## 4、如果不考虑事务隔离性，会产生哪些问题？

如果事务隔离级别设置为“不考虑事务隔离性”，那么可能会导致以下问题：

1. **幻读（Phantom Read）**：一个事务在读取某个范围的数据时，另一个事务在该范围内插入了新的数据，导致第一个事务再次读取时发现数据数量不一致。

2. **丢失更新（Lost Update）**：在事务提交之前，其他事务可能已经更新了表中的某些记录。如果当前事务也更新了这些记录，那么可能会导致丢失更新。即，当前事务的更新将被覆盖，而实际结果是两个事务都更新了相同的记录。

3. **脏读（Dirty Read）**：一个事务读取了另一个事务未提交的数据，导致读取到的数据是不一致的。

4. **不可重复读（Non-Repeatable Read）**：一个事务在读取某个数据后，另一个事务修改了该数据，导致第一个事务再次读取时发现数据不一致。

这些问题通常是由于事务隔离级别设置为“不考虑事务隔离性”导致的。在这种情况下，事务之间的冲突和不一致是无法避免的，可能会影响应用程序的正常运行。因此，在实际应用中，建议将事务隔离级别设置为较安全和可靠的级别，如“提交后隔离”。



## 5、乐观锁和悲观锁的区别是什么？

乐观锁和悲观锁是两种不同的并发控制策略，它们的主要区别在于对待数据竞争的态度和处理方式上。

1. **乐观锁**：乐观锁在操作数据时持乐观态度，认为并发冲突不会频繁发生，因此在数据操作时不会直接上锁。只有在执行更新操作时，才会检查在此期间是否有其他用户修改了数据。如果检测到数据冲突，则放弃当前操作；否则，执行更新。乐观锁适用于==读多写少==的场景，因为在这种情况下，冲突较少，乐观锁可以提供更好的性能。然而，乐观锁无法解决脏读的问题。

2. **悲观锁**：悲观锁在操作数据时持悲观态度，认为并发冲突一定会发生，因此在数据操作时会直接上锁，以避免其他用户同时修改数据。这种策略会对其他用户的操作造成阻塞，直到当前操作完成并释放锁。悲观锁适用于==写多读少==的场景，因为在这种情况下，冲突较多，悲观锁可以避免其他用户的操作被阻塞。然而，悲观锁可能导致读取操作的性能下降。

总的来说，乐观锁和悲观锁各有优缺点，需要根据具体的业务场景和需求来选择使用哪种策略。



## 6、数据库设计规约

- ==【强制】表名不使用复数名词==
- 【推荐】表的命名最好是加上“业务名称_表的作用”。如，`edu_teacher`
- ==【强制】表必备三字段：`id`, `gmt_create`, `gmt_modified`==
- 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。
  - 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。
- ==【强制】表达是与否概念的字段，必须使用 `is_xxx` 的方式命名，数据类型是 `unsigned tinyint` （1 表示是，0 表示否）。==
  - 说明：任何字段如果为非负数，必须是 unsigned。 
  - ==注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。==数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。
  - 正例：表达逻辑删除的字段名 `is_deleted`，1 表示删除，0 表示未删除。
- 【强制】小数类型为 `decimal`，禁止使用 `float` 和 `double`。 
  - 说明：`float` 和 `double` 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 `decimal` 的范围，建议将数据拆成整数和小数分开存储。
- 【强制】如果存储的字符串长度几乎相等，使用 `char` 定长字符串类型。
- 【强制】`varchar` 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 `text`，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
- 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 
  - 说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。
- ==【强制】不得使用外键与级联，一切外键概念必须在应用层解决。==外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 

